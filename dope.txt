* ntlm_message.hpp
virtual destructor
write proper include guard (PAL_NTLM_MESSAGE_HPP_INCLUDED)
include the required headers (stdint.h)
comment after #endif
use syntax highlighting

* type1_message.hpp
use explicit single argument constructor
order of public/private
!repeating includes
avoid _prefix of local variables
repeating virtual 
(const member variable)

* type1_message.cpp
initialize class properly
import namespaces does not improve readability
consider size_t instead of int (remember prefixing)
const member variable
avoid magic constants(eg, const size_t flags_offset = 12;)
... but only when it adds value (not needed for message)
prefer prefixing over opening the namespace

* type2_message.hpp
certainly do not import namespaces in header files
pass by const ref (buffer)
prefer use const methods (query/command separation)
do not use the throw specifiers (ctor)

* type2_message.cpp
pass by const ref (buffer) (*)
include order (what about own/std/project, hubert)
avoid superfluous use of () (eg in return or sizeof)

prefix size_t with std
layout of array initializer (not robust)

* type3_message.hpp
prefer forward declarations
do not write explicit on multi argument constructors (due to explanation)
avoid default arguments

star wars (place & in K&R, BS, and unified)
avoid fragile code layouts / prefer robust code layout

* type3_message.cpp
order in initializer list
complete initializer list
do not "throw new"

beware of side-effects when using iomanips

use anonymous namespaces for const (but also types)
alphabetic order of includes
(-Wall and -Wextra)
space after keywords

use assignment instead of initialization (data_offset)
use anonymous namespace instead of static for local (pal_internal)
sizeof(prefix) -> sizeof prefix
std::endl is implicitly flushing the stream (in ostream)

camelCase inside debugstring (sspFlags, sessionKey)
vote for enums

